/*********************************************************************************
 *                                ASPECTOS GENERALES                             *
 *********************************************************************************/

//Esqueleto de funcion anonima en JS
const myVar2 = (param) => {/*myFunction*/}

//Ejemplo de funcion anonima + uso de funcion nativa de JS
const myVar1 = myArray.split('.').every(str => {
    if(condition1) {
        return a;
    } else if(condition2) {
        return b;
    } else {
        return c;
    }
});

//El operador spread permite a un array o cadena ser usado donde se espera un numero de argumentos determinado
//s̶u̶m̶(̶n̶u̶m̶e̶r̶o̶s̶[̶1̶]̶,̶ ̶n̶u̶m̶e̶r̶o̶s̶[̶2̶]̶,̶ ̶n̶u̶m̶e̶r̶o̶s̶[̶3̶]̶)̶;̶
function myFunction(x, y, z) { }
var args = [0, 1, 2];
myFunction(...args);
//Algunos ejemplos son:
const numeros = [1, 2, 3];
sum(...numeros); // sum -> 6
Math.min(...numeros); // min -> 1

/*********************************************************************************
 *                        FUNCION FLECHA VS STANDARD                             *
 *********************************************************************************/
Función estándar: En una función estándar, el valor de "this" se determina en función de cómo se llama a la función. El valor de "this" puede cambiar dinámicamente, dependiendo del contexto de invocación de la función.
Función de flecha: Una función de flecha no tiene su propio contexto "this". En su lugar, hereda el valor de "this" del ámbito léxico que la rodea. En otras palabras, el valor de "this" dentro de una función de flecha viene determinado por el ámbito circundante en el que se define la función de flecha.
// Standard function
function greetStandard() {
  console.log('Hello, ' + this.name);
}

// Arrow function
const greetArrow = () => {
  console.log('Hello, ' + this.name);
};

const name1 = 'John';

const person1 = {
  name: 'Alice',
  greetStandard: greetStandard,
  greetArrow: greetArrow,
};

greetStandard();   // Output: Hello, John (this refers to the global object, name1 is in the global scope)
greetArrow();      // Output: Hello, John (this also refers to the global object, name1 is in the global scope)
person1.greetStandard(); // Output: Hello, Alice (this refers to the person1 object, as it's called through the object)
person1.greetArrow();    // Output: Hello, John (this refers to the global object, as arrow functions inherit the lexical scope)


/*********************************************************************************
 *                                        ARRAYS                                 *
 *********************************************************************************/

//Sumar los elementos de un array
myArray.reduce((a, b) => a + b, 0);

//Ordenar los elementos de un array ascendentemente
myArray.sort(function(a,b){return a - b});

//Filtrar my array para solo quedarme con los pares
myArray.filter((_, index) => index % 2 === 0);

//Determinar si existe algun numero del array divisible por i
myArray.some(num => num % i === 0)

//Reemplaza ciertos elementos de un array por otros
myArray.map(elem => elem === elemToReplace ? substitutionElem : elem);

/*********************************************************************************
 *                                        STRINGS                                *
 *********************************************************************************/

//Determina si mi string de enteros esta compuesto por numero pares. Recordar que ('2' + 2 -> 22) pero que ('2' / 2 -> 1)!
myString.split('').every((index) => index % 2 === 0);

/*********************************************************************************
 *                                     REACT NATIVE                              *
 *********************************************************************************/

//Wraps the call to the authenticate() function. The arrow syntax ensures that authenticate() is not executed immediately 
during rendering, it will be executed only when the component is pressed.
onPress={() => navigation.navigate('Main')}

//React useEffect Hook

